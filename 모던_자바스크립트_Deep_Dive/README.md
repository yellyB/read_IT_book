<img src="https://user-images.githubusercontent.com/50893303/199031174-8fe1ed49-7c4f-4720-8bfe-a75d1ae19e7d.png" width='400px' />

## 모던 자바스크립트 Deep Dive


### 04 변수

변수? (=식별자) 값이 저장된 메모리 공간을 가리키는 이름
할당: 변수에 값을 저장 / 참조: 저장한 값을 읽음
*var키워드의 단점: 블록레벨스코프가 아닌 함수레벨스코프 지원. 의도치 않게 전역변수 선언되어 부작용
변수 선언: 런타임 이전/ 값의 할당: 런타임에
var = score; => 변수 선언하면?

1. [선언단계]변수 이름 등록 - 실행 컨텍스트에 등록
2. [초기화 단계]메모리 공간 확보(undefined으로 초기화)

소스코드는 1평가 -> 2실행
평가과정에서 어디에있건 모든 선언문을 먼저 실행함(=호이스팅) =>모든 식별자는 호이스팅 됨
 * 호이스팅: 변수 선언문이 코드의 선두고 끌어 올려진 것처럼 동작

- 변수: 값을 재할당 가능(undefined로 초기화되기때문에 변수에 처음으로 값을 할당하는것도 사실은 재할당)
- 상수: 단 한번만 할당할수 있는 변수

 * 가비지 콜렉터: JS같은 매니지드 언어는 메모리 해제를 가비지 콜렉터가 수행. 장-생산성확보, 메모리누수 방지/단-성능 손실

### 05 표현식과 문

값: 표현식이 평가되어 생성된 결과

리터럴: 사람이 이해할 수 있는 문자

표현식: 값으로 평가될 수 있는 문

문: 여러 토큰으로 구성. 최소 실행 단위

문 중에 표현식O과 표현식X 구별법: 변수에 할당해봄. 표현식X인 문은 변수에 할당 불가(var foo = var x; ⇒ error)

### 06 데이터 타입

- 원시타입(6개): 숫자, 문자열, 불리언, undefined, null, 심벌
- 객체타입: 객체, 함수, 배열 등

선언: 식별자의 존재만 알림 / 정의: 식별자 - 메모리 주소 연결
null - 변수에 null을 할당하는것은 이전에 참조하던값 더이상 참조하지 않겠다는 뜻
타입의 필요성
  1. 값 저장시 메모리 공간 크기 결정
  2. 값 참조시 읽어들어야할 메모리 공간 크기 결정
  3. 읽어들인 2진수 어떻게 해석할지
동적 타이핑: JS는 변수 선언시 X. 할당시에 동적 결정(유연성 높. but 신뢰성 낮)
(정적 언어는 변수 선언시점에 타입 결정:런타임 에러 줄임)
[변수 사용 주의사항(타입 체크 번거로우니)]
변수는 꼭 필요할경우에만 / 스코프는 최대한 좁게 / 전역변수 사용 지양 / 변수보다는 상수 / 목적 파악 네이밍

### 07 연산자

[동등/일치 비교 연산자]

- 동등비교(==)는 암묵적 타입 변환으로 타입 일치시킨 후 비교. 예측하기 어려우니 사용X

- 일치비교: 주의할 것 - NaN은 자신과 일치하지 않는 유일한 값(NaN === NaN) ⇒ false / +0 === -0 ⇒ true
        ㄴ 그래서 숫자가 NaN인지 조사하려면 isNaN을 사용

ES6의 Object.is메서드는 정확한 비교 결과 반환 → Object.is(NaN, NaN) ⇒ true / Object.is(-0, +0) ⇒ false

[논리 연산자]

드 모르간의 법칙: 가독성 좋게 ex) !(x||y) === (!x && !y)

### 08 제어문

break문: 코드 블록 탈출

continue문: 코드 블록 실행 중단하고 반복문의 증감식으로 실행 흐름 이동

### 09 타입 변환과 단축 평가

명시적 타입 변환(=타입 캐스팅) / 암묵적 타입 변환(=타입 강제 변환)

타입 변환은 변경 불가능한 원시값을 변경할 수 없기 때문에 새로운 원시 값을 생성하는 것임

[암묵적 타입 변환]

Falsy로 평가되는 값: false / undefined / null / 0, -0 / NaN / ‘’  ⇒ 이외엔 모두 true로 평가되는 Truthy값임

[명시적 타입 변환]

String, Number, Boolean 빌트인 생성자 함수 사용

[단축 평가]: 표현식을 평가하는 도중 결과가 확정된 경우 나머지 과정 생략
  ex) true && anything ⇒ anything / false && anything ⇒ false / true || anything ⇒ true / false || anything ⇒ anything

옵셔널 체이닝 연산자, null 병합 연산자: 좌항의 피연산자가 **null 또는 undefined**면 undefined를 반환
  ex) var elem = null;  console.log(elem?.value);  ⇒ undefined 출력

### 10 객체 리터럴

객체는 프로퍼티의 집합

프로퍼티: 객체의 상태를 나타내는 값. 키와 값으로 구성

메서드: 프로퍼티를 참조하고 조작할 수 있는 동작(프로퍼티 값이 함수일 경우 일반함수와 구분하기 위해 메서드라고함)

자바스크립트는 프로토타입 기반 객체지향 언어. 객체생성 방법 지원:
    객체 리터럴 / Object 생성자 함수 / 생성자 함수 / Object.create 메서드 / 클래스(ES6)

[프로퍼티 접근]

객체에 존재하지 않는 프로퍼티 접근하면 undefined반환(Reference Error 아님)

delete 로 프로퍼티 삭제시에도 존재하지 않는거 삭제하면 에러 없이 무시됨

### 11 원시 값과 객체 비교

원시타입 - 객체 차이점 3개

|  | 원시값 | 객체 |
| --- | --- | --- |
| 변경? | 불가능 | 가능 |
| 변수에 할당 | 메모리 공간에 실제 값 저장 | 참조 값 저장 |
| 다른 변수에 할당 | 값에 의한 전달 | 참조에 의한 전달 |

원시값 변경 불가능하다는 말의 의미(=불변성)
:재할당하면 새로운 메모리 공간을 확보해 저장 & 변수에는 새 메모리 공간 주소로 변경
=> 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다
*문자열: 유사 배열 객체이면서 이터러블 -> 인덱스로 프로퍼티 접근, length 프로퍼티 가짐
*객체: 객체를 할당한 변수는 객체가 실제로 저장된 메모리 공간의 주소가 저장됨

### 12 함수

함수 정의 방법 4가지: 함수 선언문 / 함수 표현식 / Function 생성자 함수 / 화살표 함수(ES6)

[함수 선언문]: 함수 호이스팅
	암묵적으로 생성된 식별자는 함수 객체로 초기화 => 함수 선언문 이전에 함수 호출 가능
[함수 표현식]: 변수 호이스팅
	변수에 할당되는 값이 함수 리터럴인 문
=> 변수 선언은 런타임 이전에 undefined로 초기화. 할당문의 값은 런타임에 평가됨

[화살표 함수]

함수 선언문과 함수 표현식과 다른 점:
	- 생성자 함수로 사용할 수 없음
	- this 바인딩 방식 다름
	- prototype 프로퍼티 없음
	- arguments 객체 생성 안함

매개변수: 함수 내부로 입력 전달받는 변수( function add(**x, y**){} ) / 인수: 입력( add(**2, 5**); )
할당되지 않은 매개변수는 undefined
매개변수보다 인수가 더 많은 경우 초과된 인수는 무시됨

[콜백 함수] 184p

콜백 함수: 다른 함수의 내부로 전달되는 함수. 중첩 함수에서 내부 함수(헬퍼)의 역할을 함. 고차함수에 의해 호출
고차 함수: 콜백 함수를 전달받은 함수. 고차함수는 콜백 함수를 자신의 일부로 합성. 콜백 함수 호출시점 결정함

함수형 프로그래밍은 순수 함수를 통해 부수 효과 최대한 억제해 오류 피하고 안정성 높이는 것

### 13 스코프

스코프? 식별자가 유효한 범위 =식별자를 검색할 때 사용하는 규칙 = 네임 스페이스
스코프 체인

- 변수 참조시 스코프 체인을 통해 상위 스코프 방향으로 이동하며 변수를 검색함
- 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한것
- 상위 스코프에서 유효한 변수는 하위에서 참조 가능 but 하위 스코프에서 유효한 변수는 상위 스코프에서 참조 불가
렉시컬 스코프(=정적 스코프):
  함수를 어디서 호출했는지가 아닌 어디서 정의했는지에 따라 상위 스코프 결정
  함수의 상위 스코프는 언제나 자신이 정의된 스코프

스코프에 대해서 얘기해주실래요?
의미)스코프는 식별자가 유효한 범위라는 뜻이구요.
좀 풀어서 말하자면 어떤 변수를 참조하려고 할 때 그 변수의 값이 뭔지 자바스크립트 엔진이 검색할때 사용하는 규칙입니다.
체인)함수가 중첩되어 실행하는 경우 스코프도 함수처럼 중첩되어서 스코프체인이라는 계층적 구조를 갖게 되구요. 변수를 참조할 때 자바스크립트 엔진이 상위 스코프 방향으로 이동하면서 참조하려는 변수를 검색합니다.

### 14 전역변수의 문제점

지역 변수의 생명주기 = 함수의 생명 주기 / 전역 변수의 생명주기 = 전역 객체의 생명 주기
전역 객체 window는 웹페이지를 닫기 전까지는 유효함. 따라서 전역 변수 = 전역객체 생명주기 일치

[전역 변수 문제점]
1) 전역 변수를 선언하면 모든 코드가 참조할 수 있고 변경할 수 있어서 가독성 나빠짐+의도치않게 상태가 변경될 수 있는 위험성
2) 생명주기가 길어서 var로 선언하는 경우 의도치 않은 재할당
3) 스코프 체인에서 검색할 때 종점에 존재하기 때문에 검색 속도가 제일 느림
4) 전역 스코프를 공유하기때문에 네임스페이스 오염(다른 파일에서 사용할수 있는 위험)
전역 변수 억제 방법: 되도록 지역변수 사용, 스코프 좁게
해결방법: 1 즉시실행함수/ 2 클로저(모듈 패턴)/ 3 ES6모듈로 모듈스코프(script태그에 type="module")

### 15 ES6의 let, const

[var의 문제점]

1. 중복 선언 가능 -> 변수값이 변경되는 부작용
2. 함수레벨스코프 -> 함수의 코드블록만을 지역 스코프로 인정. 코드 블록 내에서 선언해도 전역 변수가 됨
3. 변수 호이스팅 -> 변수 선언문 이전에 참조 가능(할당문 이전에 참조하면 undefined반환), 오류 발생위험

[let]

- 변수 중복 선언 금지
- 블록 레벨 스코프
- 변수 호이스팅(이 발생하지 않는것처럼 동작)
-> var키워드는 선언+초기화가 한번에 진행되어서 선언문 이전에 접근해도 에러 없이 undefined반환
하지만 let은 분리되어 진행. 초기화 단계는 선언문에 도달했을때 실행됨. 그전엔 레퍼런스에러
이와같이 스코프 시작지점~초기화지점까지 변수참조불가능구간을 일시적사각지대(Temporal Dead Zone)

[const]

- 반드시 선언과 동시에 초기화
- 재할당 금지. 장점: 1상태 유지/ 2가독성/ 3유지보수 편의

var, let, const에 대해서 얘기해주실래요?
ES5까지는 var만을 사용했었는데요. var에는 몇가지 문제점이 있었는데
한번 선언한 변수를 또 다시 var로 선언할 수 있어서 값이 변경되어버리는 부작용이 있구요.
var는 함수레벨 스코프를 따르기때문에 if문이나 for문같이 코드블록 내에서 선언해도 블록 외부의 값에 영향을 주는 문제점이 있었습니다.
또 변수 호이스팅으로 변수 선언문 이전에 변수를 참조할 수 있어서 오류발생 여지를 주는 문제점이 있었습니다.
그래서 ES6에서 let과 const 키워드가 추가되었는데요.
var에서 가능했던 변수 중복선언이 불가능하게 되었구요, 블록레벨 스코프를 따르기때문에 예를들어 for문에서 i로 값을 사용했더라도 for문 외부에서는 그 값이 유효하지 않게 되었습니다.
또 마치 호이스팅이 발생하지 않는것처럼 동작해서 선언문 이전에 변수를 참조하게 되면 reference error가 발생합니다.
그 중에서도 const는 재할당이 불가능하기 때문에 유지보수의 편의성이라는 장점이 있어 코드를 작성할 때 되도록 const를 사용하고 있습니다.

### 17 생성자 함수

객체 리터럴로 객체 생성시 문제점: 단 하나의 객체만 생성 가능
=> 생성자 함수로 객체 생성하면 여러개 생성
????생성자 함수 내부
????생성자 함수 내부에 return 문 반드시 생략

### 19 프로토타입

[장단점]
공통 부분을 프로토타입에 정의하여 재사용성, 메모리 절약 가능, 유연한 프로그래밍 가능
단점: class형에 익숙하면 불편, 없을거라 생각했던 속성이 프로토타입에 있어서 예상하지 못한 동작 할수도??????

for...in문
 : 객체의 프로퍼티 개수만큼 순회. 변수에 프로퍼티 키를 할당

### 20 strict mode

- 자바스크립트 문법을 좀 더 엄격히 적용
- ESLint 같은 도구 - 유사한 효과

strict mode에서 함수를 일반함수로 호출하면 this에 undefined가 바인딩

### 22 this

this란? 자신이 속한 객체 or 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
this 바인딩(식별자와 값을 연결하는 과정)은 함수 호출 방식에 따라 동적 결정 - this와 this가 가리킬 객체를 바인딩
*상위 스코프 결정방식인 렉시컬 스코프는 함수객체 생성시에 결정/this바인딩은 함수 호출 시 결정

[함수 호출 방식]
1 일반함수 - 일반 함수로 호출된 모든 함수(중첩, 콜백..) 내부의 this에는 전역 객체 바인딩
2 메서드 - 메서드 이름 앞에 마침표로 기술한 객체 바인딩
3 생성자 - 생성자 함수가 미래에 생성할 인스턴스 바인딩

[apply/call/bind]메서드에 의한 간접 호출 - ???????
**apply** - 호출함 함수의 인수를 배열로 묶어 전달 .apply(thisArg, [1,2,3])
**call** - 인수를 쉼표로 구분한 리스트로 전달 .call(thisArg, 1,2,3)
⇒ 둘의 본질적인 기능: 함수 호출하기. 함수를 호출하면 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩함
⇒ 둘의 대표적인 용도는 유사배열객체에 배열 메서드 사용하는 경우.
**bind** - 함수호출X. this로 사용할 객체만 전달

this에 대해서 얘기해주실래요?
자신이 속해있는 객체를 가리키는데 사용하는 키워드인데요.
this는 함수가 호출되는 방식에따라서 동적으로 결정됩니다.
예를들어서 중첩함수나 콜백함수나 어떤 함수든 일반 함수로 호출되면 모두 전역 객체가 바인딩되구요, 메서드는 쩜 앞에 쓰여있는 객체가 this에 바인딩 됩니다.
그래서 호출 방식에 따라 this가 결정되기때문에 원하는 값이 this로 바인딩 되지 않는 경우가 있어 이럴때는 bind 메서드로 this가 불일치되는 문제를 해결합니다.
하지만 저는 주로 ES6에서 새로 생긴 화살표 함수를 사용하기때문에 직접 bind메서드를 사용해본 적은 아직까지는 없었습니다.

arrow function에 대해서 얘기해주실래요?
화살표 함수가 일반 함수와 구별되는 가장 큰 특징은 this인데요. 일반 함수는 함수가 호출되는 방식에 따라 this가 동적으로 결정되기때문에 콜백함수나 메서드도 일반함수로 호출하게 되면 모두 this에 전역객체가 바인딩됩니다. 그래서 ES6이전에는 bind메서드를 사용해서 값을 바인딩해주었는데요, 화살표함수를 사용하게되면 상위 스코프의 this를 그대로 참조할 수 있습니다.

### 23 실행 컨텍스트

정의? 실행할 코드에 제공할 환경 정보들을 모아놓은 객체
평가과정(선언문) / 실행과정(선언문 이외의 문)

[역할]

1. 전역 코드 평가 - 변수 선언문과 함수 선언문이 먼저 실행,
2. 전역 코드 실행 - 값이 할당, 함수 호출. 함수 호출? -> 함수 내부 진입
3. 함수 코드 평가 - 매개변수와 지역 변수 선언문 실행 => 지역 스코프에 등록, arguments객체 생성, this바인딩
4. 함수 코드 실행 - 매개변수와 지역 변수에 값이 할당. 함수 종료되면 이전으로 되돌아가기위해 스코프, 식별자(스코프 체인), 코드실행순서 관리 필요

[스택] : 코드 실행 순서 관리

1. 전역 코드 평가와 실행 - 평가=> 전역 실.컨 생성&스택에 푸시. 변수x와 함수foo는 전역 실.컨에 등록
실행=> 변수x에 값 할당 & 함수foo가 호출
2. foo 함수 코드 평가 실행 - 전역 코드 일시 중단. 코드 제어권이 foo함수 내부로 이동
평가 => foo함수 실.컨 생성&스택에 푸시. 지역변수 y와 bar함수 실.컨에 등록
실행 => 지역변수y에 값 할당 & 중첩함수bar호출
3. bar 함수 코드 평가 실행 - foo함수 코드 일시 중단. 코드 제어권이 bar함수 내부로 이동
평가 => bar함수 실.컨 생성&스택에 푸시. 지역변수 z가 실.컨에 등록
실행 => 지역변수z에 값 할당. bar함수는 종료
4. foo 함수 코드로 복귀 - 제어권 다시 foo에게. bar함수 실.컨은 스택에서 팝. foo는 종료
5. 전역 코드로 복귀 - 제어권 다시 전역 코드에게. foo함수 실.컨은 스택에서 팝. 전역 실.컨도 팝

[렉시컬 환경] : 스코프와 식별자 관리
식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조 기록하고 있음. 실.컨 구성하는 컴포넌트임
실행컨텍스트 : LexicalEnvirionment / VariableEnvironment(snap shot)로 구성됨
ㄴEnvironmentRecord(식별자, 바인딩) / OuterLexicalEnvirionment(상위 스코프)로 구성

### 24 클로저

정의? 함수와 그 함수가 선언된 렉시컬 환경과의 조합
외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첨합수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩함수를 클로저라고 함
클로저의 의해 참조되는 상위 스코프의 변수를 자유 변수 라고 함
클로저의 장점: FP에서 부수효과 최대한 억제, 오류 피함, 안정성 높이기 위해

클로저에 대해서 얘기해주실래요?
[개념]
코드는 실행컨텍스트에 의해 관리되는데 실행컨텍스트 객체의 Environment 내부슬롯에 현재 실.컨의 상위 스코프에 대한 참조 정보가 담기게 되는데요. 자신이 존재하는 한 이 상위 스코프를 기억하고 있어서 이미 외부 함수의 생명주기가 종료되었더라도 외부 함수의 변수를 참조할 수 있는데 이런 중첩 함수를 클로저라고 합니다.
[사용]
클로저는 보통 객체지향에서 private의 개념과 비슷하게 상태를 관리하기 위해 사용되는데, 특정 함수에 의해서만 상태가 변경되도록 허용해서 의도치 않게 상태가 변경되는 경우를 예방할 수 있습니다.

### 26 ES6 함수의 추가 기능

일반 함수는 constructor
but ES6의 메서드 & 화살표 함수는 non-constructor(인스턴스 생성 불가)

[화살표 함수]
⇒ 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제 해결하기 좋음
일반 함수와의 차이:
 1. 인스턴스 생성할 수 없는 non-constructor. ptorotype프로퍼티 없음. 프로토타입 생성X
 2. 중복된 매개변수 이름 불가
 3. this, arguments, super, new.target 바인딩 갖지 않는다. (상위 스코프의 것들을 참조)

▷ this
함수가 어떻게 호출되었는지에 따라 동적으로 결정되는데,
클래스 내부에서는 strict mode가 적용되고 그 안에서 일반함수는 모두 this에 undefined가 바인딩 됨
⇒ 이런 문제 때문에 ES6이전에는 /this를 회피/인수로 this를 전달/bind메서드 를 사용했었다.

**ES6에서는 화살표 함수로 “콜백 함수 내부의 this문제” 해결**
화살표 함수 this에는 상위 스코프의 this를 그대로 참조 (lexical this)
내부 바인딩 갖지 않기 때문에 call, apply, bind 사용해도 this 교체 불가(호출은 가능)
주의! 메서드에선 사용하지 말아야. 왜? 호출한 객체를 가리키는게 아니라 상위 스코프를 this로 가져와서. 메서드는 ES6메서드 축약 표현 사용하기

### 34 이터러블

이터레이터:
- 이터레이터 프로토콜을 준수하는것을 말함.
- 이터레이터는 next메서드를 가지고 있고 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환함

이터러블 프로토콜: for...of문, 스프레드 문법, 디스트럭처링 할당
이터레이터 프로토콜: next메서드, 순회하며 value와 done프로퍼티를 갖는 리절트 객체 반환
⇒ iterable: 순회가능한 자료구조 / iterator: 이터러블 탐색 위한 포인터

for...in ⇒ 프로퍼티 순회하며 열거함
for...of ⇒ 이터레이터의 next메서드로 순회. value 프로퍼티 값을 변수에 할당.
이터레이터 리절트 객체의 done프로퍼티 값이 false면 계속, true면 순회 중단

이터레이션 프로토콜 필요성: 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정. 인터페이스 역할

### 37 Set과 Map

[set]
중복X 유일한 값들의 집합.
배열과의 차이: 1. 동일한 값 중복 포함X / 2. 요소 순서에 의미 X  / 3. 인덱스로 요소에 접근 X

[map]
키-값
객체와의 차이: 1. 키로 모든 값 사용가능 / 2. 이터러블임 / 3. 요소 개수 확인 : map.size

### 38 브라우저의 렌더링 과정

렌더링 과정

1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 등 필요한 리소스 요청
2. 브라우저 렌더링 엔진 - 서버로부터 응답된 HTML, CSS파싱하여 DOM과 CSSOM생성. 결합하여 렌더 트리 생성
▷ HTML 파싱: 서버가 응답한 HTML은 문자열인 텍스트(바이트→문자→토큰→노드→트리 자료구조 DOM)
▷ CSS파싱: 위랑 동일. CSSOM 생성
3. 브라우저 JS엔진 - 자바스크립트 파싱하여 추상적 구문 트리 AST(Abstact Syntax Tree)생성, 실행. DOM API통해 DOM이나 CSSOM변경할수있음
4. 렌더 트리를 기반으로 HTML요소의 레이아웃 계산하여 브라우저 화면에 HTML 요소 페인팅
(노드 추가 삭제 → 뷰포트 크기 변경 → HTML레이아웃 변경발생? → 리페인팅)

HTTP: 웹에서 브라우저-서버 통신하기 위한 프로토콜

리플로우: 레이아웃 계산을 다시. 노드 추가/삭제, 요소 크기/위치 변경, 윈도우 리사이징
리페인트: 렌더트리 기반으로 다시 페인트 ⇒ 레이아웃 변경 없으면 리페인팅만

JS엔진은 직렬적으로 파싱 수행(동기적)
⇒ body 가장 아래에 JS위치
1. 아직 없는 DOM을 조작하면 에러
2. JS 로딩,파싱,실행으로 HTML 렌더링에 영향, 페이지 로딩 시간

async : JS의 파싱과 실행은 JS파일 로드가 완료된 직후 실행. script 순서 보장X
defer : JS의 파싱과 실행은 HTML 파싱이 완료된 직후(=DOM 생성 완료 직후)

### 40 이벤트

이벤트 핸들러 : 이벤트가 발생했을 때 호출될 함수 (브라우저에게 함수 호출 위임한다)

이벤트 핸들러 등록 3가지

 1) 이벤트 핸들러 어트리뷰트

<button onclick=”func()”>click</button> 같이 함수 호출문을 할당

HTML과 자바스크립트 관심사가 다르므로 분리하는 것이 좋음.

하지만 CBD(Component Based Dev)에서는 이렇게 함.

왜냐면 CBD에서는 HTML, CSS, JS를 전부 뷰의 구성요소로 봐서 관심사 다르다고 생각X

2) 이벤트 핸들러 프로퍼티

$button.onclick = functions () {} 같이 이벤트 타깃+이벤트 타입+핸들러 등록

1번방식도 이거처럼 결국 프로퍼티로 변환되는거지만 이방식은 HTML과 JS섞이는 문제 해결가능. 하지만 이벤트 하나만 등록된다는 단점

3) addEventListener 메서드

[타깃].addEventListener([이벤트타입], 핸들러, useCapture)

요소에 여러 이벤트 등록 가능. 이벤트 핸들러 등록된 순서대로 호출 됨

이벤트 객체: 이벤트 발생하면 동적으로 생성. 이벤트 핸들러의 첫 번째 인수로 전달됨

이벤트 전파: DOM트리를 통해 전달. 캡쳐링: 하위 요소로 전파 / 버블링: 상위 요소로

이벤트 위임: <ul><li></li> ... </ul>일때 li에 각각 핸들러 등록하는게 아니라 상위 DOM요소에 핸들러 등록하는 방법

이벤트 핸들러 this

 1) 어트리뷰트 방식: this에는 전역객체 바인딩 됨. handleClick함수는 이벤트 핸들러에의해 일바 함수로 호출됨

 2) 프로퍼티 & addEventListener : this에 이벤트를 바인딩한 DOM요소 바인딩됨.

여기서 주의할점: 클래스에서 this는 생성할 인스턴스를 가리키는게 아니라서 따로 바인딩해줘야함

### 42 비동기

이벤트 루프

- 콜 스택: (=실행 컨텍스트)
- 태스크 큐: setTimeout, setInterval같은 콜백 함수 또는 이벤트 핸들러 일시적 보관
- 이벤트 루프: 콜 스택이 비어있고 태스크 큐에 대기중인 함수가 있으면 순차적으로 태스크 큐에서 대기중인 함수를 콜 스택으로 이동시킴

### 45 프로미스

Promise 생성자 함수를 new연산자와 함께 호출하면 Promise객체 생성
프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체

| 상태 | 의미 | 상태 변경 조건 |
| --- | --- | --- |
| pending | 비동기 처리 아직 수행X | 프로미스 생성된 직후 기본 상태 |
| fulfilled | 처리 성공 | resolve 함수 호출 |
| rejected | 처리 실패 | reject 함수 호출 |

fulfilled & rejected 상태 = settled 상태 (pending이 아닌 상태. 처리가 수행됨)

[try catch] 에러는 호출자(콜스택 아래)방향으로 전파됨. 하지만 비동기 함수를 호출한 함수(ex setTimeout)는 콜백 함수를 호출한 당사자가 아님. 따라서 catch 블록에서 캐치 불가

[후속 처리 메서드]: then, catch, finally ⇒ 모두 프로미스를 반환한다
 1. then: 첫번째 콜백 함수는 비동기 처리결과, 두번째 함수는 에러를 인수로 받음(에러처리는 catch에서 하길 권장)
 2. catch: 한개의 콜백 함수 인수로. rejected상태인 경우만 호출됨
 3. finally: 한개의 콜백 함수 인수로. 성공 실패 상관없이 무조건 한 번 호출

[체이닝] 프로미스는 콜백 헬이 발생하진 않지만 콜백 패턴을 사용하므로 콜백 함수 사용안하는건 아님
가독성이 좋지 않기때문에 ES8의 async/await를 통해 해결 가능

[정적 메서드] Promise.all은 여러 개의 비동기 처리를 병렬로. (순차적X). 하나라도 rejected되면 즉시 종료

[마이크로태스크 큐] 프로미스의 후속처리 메서드 콜백 함수가 일시 저장. 태스크 큐보다 우선순위 높음

[fetch함수] HTTP응답을 나타내는 response객체를 래핑한 Promise 객체 반환함

### 46 제너레이터와 async/await

[제너레이터]
- 코드 블록의 실행을 일시 중지(yield) 했다가 필요한 시점에 재개(next)할 수 있는 함수
- function* 키워드로 선언

일반 함수와의 차이
 1. 제너레이터는 함수 실행을 함수 호출자가 제어할 수 있다.
 2. 함수 호출자와 상태를 전달 & 받을 수 있다.
 3. 코드를 실행하는것이 아니라 제너레이터 객체(이터러블이면서 이터레이터)를 반환한다.

활용: 1. 이터러블 구현  2. 비동기 처리

[async/await]
▷ async
  암묵적으로 resolve하는 프로미스 반환
▷ await
  - 프로미스가 settled(수행된)상태까지 대기하다가 settled이 되면 프로미스가 resolve한 처리 결과 반환
  - 프로미스와는 다르게 async/await는 명시적으로 호출할 수 있기 때문에(???) 호출자가 명확. try catch문 사용할 수 있다.
  - 에러 발생 시 async 함수 내에서 catch로 에러 처리 안하면 async함수는 에러를 reject하는 프로미스 반환
