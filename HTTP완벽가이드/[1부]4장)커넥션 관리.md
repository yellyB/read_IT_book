	4장 커넥션 관리	85p~122p
112	TCP 커넥션 - 서로 주고받는 메시지들은 손실, 손상, 순서보장 되어 안전하게 전달됨	  
113	HTTP 커넥션은 TCP 커넥션(신뢰가능)	  
114	TCP는 IP패킷(데이터그램)이라는 조각으로 나눠 데이터 전송	  
115	IP패킷은 다음을 포함: IP패킷 헤더, TCP 세그먼트 헤더, TCP데이터 조각	  
116	TCP는 여러개 연결 가능. 포트 번호를 통해 커넥션 유지 / TCP커넥션은 네가지로 식별: 발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트	  
117	운영체제는 TCP커넥션 생성 관련된 소켓 API 제공	  
118	HTTP는 TCP 바로 윗 계층이라 TCP 성능에 영향 받음	  
119	HTTP트랜잭션 지연엔 여러 원인: 웹서버 IP주소와 포트번호 알아내야함, 서버가 커넥션 응답하길 기다림, 메시지가 전달&처리되는데 시간소요, ...	  
120	성능관련 요소 1. TCP커넥션 핸드셰이크 지연: 커넥션을 맺기 위해 연속으로 IP패킷 교환하는데 이때 HTTP 성능 저하	  
121	 2. 확인응답 지연: 성공적인 데이터 전송 보장하기 위해 확인 체계 있는데, HTTP는 데이터 패킷이 확인 응답이 낑겨갈 기회 적음	  
122	 3. TCP 느린 시작: 처음에는 속도 제한이 심하다가 점점 완화됨(=튜닝). 그래서 처음에는 튜닝된것보다 느림	  
123	 4. 네이글 알고리즘과 TCP_NODELAY: 잘게 나뉘어 많은 패킷이 전송되지 않도록 TCP 데이터를 한 덩어리로 합치는 알고리즘. 일정량 쌓였을때 데이터 전송함	  
124	 5. TIME_WAIT의 누적과 포트 고갈: 이전 커넥션과 주소랑 포트번호 겹치지 않도록 하다가 포트 고갈 문제. 혹은 너무 많은 대기상태 블록 주의	  
125		  
126	HTTP는 프락시 서버 같은 중개 서버 허락. HTTP 메시지는 중개 서버 거치면서 전달	  
127	TCP 성능 위해선 커넥션 관리 중요	  
128	HTTP 커넥션 성능 향상시킬 수 있는 네가지: 병렬, 지속, 파이프라인, 다중	  
129	 1. 병렬 커넥션: 여러개 웹페이지 더 빠르게 내려받음. 하지만 항상 빠르진 않음(ex. 네트워크 대역폼 좁을 때)	  
130	  항상 더 빠르진 않지만 느끼기에 더 빠름	  
131	 2. 지속 커넥션: 처리가 끝나도 커넥션을 유지하는것. TCP의 느린 시작으로 인한 지연 피할 수 있음  /  지속-병렬 함께 사용할때 효과적	  
132	 지속 커넥션 두 가지: keep-alive, '지속'  / keep-alive: HTTP/1.0+에서 사용	  
133	  keep-alive 의 설명 ~~	  
134	  keep-alive가 기본으로 사용되는건 아니고 요청 헤더 보내야함, 서버에서 응답 헤더 없으면 끊었단 뜻	  
135	  dumb 프락시에서 keep-alive 사용할때 문제: 프락시가 커넥션 헤더 이해하지 못해서 다음 프락시에 그대로 전달	  
136	   ㄴ=> 이같은 잘못된 통신 때문에 브라우저 혹은 서버가 타임아웃나서 커넥션 끊길때까지 기다림	  
137	   그래서 프락시는 Connection헤더 절대 전달하면 안됨	  
138	지속 커넥션 이해할 수 있는 영리한 프락시라면 원하는 효과 얻기 가능	  
139	HTTP/1.1의 지속 커넥션: 기본적으로 활성화되어있음, 끊으려면 명시적으로 끊기 해줘야함	  
140	요청에 Connection: close 헤더 보내면 추가요청 불가	  
141	HTTP/1.1은 파이프라이닝 가능. 요청을 큐에. 성능에 굿	  
142	커넥션 끊을 때 에러 상황에서는 헤더 중간에 끊길수도. 데이터 전송중에 끊으면? 문제	  
143	ㄴ이거 해결 위해 Content-Length 헤더 가지고 있어야함	  
144	GET, HEAD, PUT, DELETE, 등은 멱등(언제나 같은 결과 반환), 멱등하지 않은 POST같은 요청은 파이프라인 통해 요청하면 안됨. 알수없는 결과 초래하기 때문	  
145	커넥션 끊기에는 전체끊기, 절반끊기.  에러 예방하기 위해 '절반 끊기' 사용해야함	  
146	커넥션 제대로 끊으려면 절반 끊기 하고 나서도 상태 검사 주기적으로 해야함	  
