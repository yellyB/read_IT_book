354(331p)~

다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발

<br/>

**다이제스트 인증의 개선점**

- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
- 악의적인 사람들을 차단
- 메시지 내용 위조를 막는 것도 가능
- 그 외 잘 알려진 형태의 공격을 막는다.

1. 비밀번호를 보내는 대신, 클라이언트는 비밀번호를 비가역적으로 뒤섞은 ‘지문(fingerprint)' 혹은 ‘요약(digest)'을 보낸다.
2. 단방향 요약: 128비트 요약으로 변환
3. 재전송 방지를 위한 난스(nonce) 사용: 서버는 클라이언트에게 난스'라고 불리는 증표를 건네줌. 요약은 특정 난스 값에 대해서만 유효
4. 다이제스트 인증 핸드셰이크: 강화된 버전의 인증. 기존 헤더에 몇몇 새 옵션이 추가

<br/>

**다이제스트 인증세션**

인증 세션은 클라이언트가 다른 서버로부터 www-Authenticate 인증요구를 받을 때까지 지속  
난스가 만료되면? 서버는 오래된 Autholization 헤더 정보를 받아들이는 것을 택 or 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환

<br/>

**사전(preemptive) 인가**

클라이언트가 다음 난스가 무엇이 될지 미리 알고 있다면(=Authorization 헤더를 계산), 요청/인증요구 사이클은 생략 가능

- 다음 난스 미리 생성하기: 서버가 다음 난스를 Authentication-InR) 성공 헤더에 담아서 미리 보낸다.
- 제한된 난스 재사용: 짧은 시간 동안 같은 난스를 재사용하는 것을 허용
- 동기화된 난스 생성: 클라이언트와 서버가 동기화 & 예측 가능한 난스 생성 알고리즘 사용

<br/>

**난스 선택**

RFC 2617은 다음과 같은 가상의 난스 공식을 제안

```jsx
BASE64(타임스탬프H(타임스탬프":" ETag ":"개인키))
```

<br/>

**보호 수준(Quality of Protection) 향상**

qop 필드는 요약 헤더의 세 가지 헤더 WWW-Authenticate, Authorization,Authenticzation-Info에 모두 존재할 수 있다.

<br/>

**다이제스트 인증 작업을 할 때 고려**

- 다중 인증요구: 서버는 한 리소스에 대해 여러 인증을 요구할 수 있다 ⇒ 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다.
- 오류처리: 인증에서 값이 적절하지 않는 경우 알맞은 응답은 400 Bad Request
- 보호 공간(Protection Space): 접근한 서버의 루트 URL과 결합되어, 보호 공간을 정의
- URI 다시 쓰기: 프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 한다. 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로, 다이제스트 인증은 이러한 변경에 의해 실패할 수 있다.
- 캐시: Authorization 헤더를 포함한 요청&응답을 받은 경우, 다음의 두 Cache-Control 지시자(must-revalidate, public) 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안 된다.

<br/>

**보안에 대한 고려사항**

RFC 2617은 HTTP 인증 제도에 내재된 보안 위협의 일부를 정리하는 일을 함

1. 헤더 부당 변경
   ⇒ 양 종단 암호화나 헤더에 대한 디지털 서명이 필요
2. 재전송 공격
   : 폼 데이터를 전송할 때 이전에 사용했던 자격을 재사용해도 문제 없이 동작해버린다면 안됨. 틀림없이 같은 난스 값을 반복해서 사용한 것  
   ⇒ 클라이언트의 IP 주소, 타임스탬프 리소스의 ETag, 개인 서버 키에 대한 요약을 포함하는 난스를 서버가 생성하도록  
   ⇒ 그런데 이 방법의 결점: 클라이 언트의 IP를 시용하게 되면, 같은 사용자로부터 의 요청이 다른 프락시를 통과하게 될 수도 있는 프락시 팜은 사용할 수 없게 된다.  
   ⇒ 재전송 공격을 완전히 피할 수 있는 한 방법: 매 트랜잭션마다 유일한 난스 값 사용
3. 다중 인증 메커니즘
   : 클라이언트에게 가장 강력한 인증 메커니즘을 선택해야 할 의무가 있는 것은 아니기 때문에, 결국 인증의 강도는 선택 지 중 가장 약한 것과 같다.  
   ⇒ 이 문제를 피하는 방법: 클라이언트가 언제나 가능한 한 가장 강력한 인증 제도를 선택하는 것  
   ⇒ 그런데 이 방법은 사내 네트워크같이 모든 클라이언트가 강력한 인증 제도를 지원할 수 있는 경우만 실현 가능
4. 사전(dictionary) 공격
   : 전형적인 비밀번호 추측 공격  
   ⇒ 크래킹하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는 것, 괜찮은 비밀번호 만료 정책
5. 악의적인 프락시와 중간자 공격(Man-in-the-Middle Attack)
   : 리다이렉션 기술과 차단 프락시의 도입으로 사용자는 요청이 프락시를 통과한다는 것조차 눈치 채지 못함. 이들 프락시 중 하나가 악의적이거나 보안이 허술? 클라이언트는 중간자 공격에 취약해짐
   ⇒ SSL을 사용
6. 선택 평문 공격
   : 클라이언트는 응답을 생성하기 위해 서버가 제공한 난스를 사용. 그러나 보안이 허술 or 악의적인 프락시가 중간에 끼어든다? 그것은 응답을 위한 난스를 제공할 수 있다.
   ⇒ 서버에서 제공된 난스 대신, C난스 지시자를 사용
7. 비밀번호 저장
   : 인증 비밀번호 파일이 유출되면, 모든 문서는 공격자에게 노출
   ⇒ 비밀번호 파일 안전하게 보호
   ⇒ 영역 이름이 유일함을 보장하며 피해 최소화

<br/>

**진정한 보안 트랜잭션은 오로지 SSL을 통해서만 가능**
