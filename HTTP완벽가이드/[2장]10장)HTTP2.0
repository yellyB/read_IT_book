311(287p) ~

1. HTTP/2.0의 등장 배경
  - HTTP/1.1의 메시지 포맷은 단순성에 집중 ⇒ 성능은 희생
  - 커넥션 하나를 통해 요청-응답 ⇒ 응답을 받아야 그다음 요청 보낼 수 있기때문에 심각한 회전 지연
  - 그래서 병렬 커넥션, 파이프라인 커넥션 도입 ⇒ 성능 개선에 근본적인 해결책은 X
  - 구글은 SPDY(더 빠른 웹을 위한 프로토콜). 이를 기반으로 HTTP/2.0 설계
2. 개요
  - HTTP/2.0은 서버와 클라이언트 사이 TCP 커넥션 위에서 동작. 커넥션 초기화는 클라이언트가
  - 요청과 응답은 스트림을 통해. 한 개의 스트림이 한쌍의 요청과 응답 처리
  - 한 커넥션에 여러 개의 스트림 ⇒ 여러 개의 요청과 응답 처리 가능
  - 스트림에 대한 흐름 제어, 우선순위 부여 기능도 제공
3. HTTP/1.1 과의 차이점
  - 프레임: 모든 메시지는 프레임에 담겨 전송
  - 스트림과 멀티플렉싱
          - 스트림은 클라-서버 사이 교환되는 프레임들의 독립된 양방향 시퀀스
          - 클라이언트는 새 스트림 만들어 요청 보냄 ⇒ 서버는 같은 스트림으로 응답 보냄 ⇒ 스트림 닫힘
          - 스트림은 우선순위 가질 수 있음: 네트워크 느리다면 중요한 리소스에 우선순위 부여(but 우선순위 보장은 못함)
          - 한번 사용한 스트림 식별자는 다시 사용 불가 ⇒ 식별자 고갈되면 커넥션 다시 맺으면 됨
  - 헤더 압축
          - HTTP/1.1에서는 헤더 압축 없었음(과거엔 헤더 크기 별 문제 안됐었음)
          - 2.0에서는 HPACK 명세에 정의된 압축하여 ‘헤더 블록 조각’들로 쪼개져 전송
          - 압축 해제할 때 ‘압축 콘텍스트’를 사용. 압축을 풀면 이에 영향받아 바뀌기 때문에 헤더 수신 받은 쪽은 헤더 사용하지 않는 경우에도 반드시 압축 해제 수행해야함(혹은 COMPRESSION_ERROR로 커넥션 끊기)
  - 서버 푸시
          - 클라이언트에서 어떤 리소스 요구할 지 미리 알아서 서버가 보내줌
          - 서버는 미리 PUSH_PROMISE 프레임을 보내어 미리 알려줘야함 ⇒ 클라는 ‘예약됨’ 상태가 됨
          - 미리 알리는 이유는 클라이언트가 별도로 또 요청하는 경우 피하기 위함
4. 알려진 보안 이슈
  - 중개자 캡슐화 공격(Intermediary Encapsulation Attacks): HTTP/2.0 메시지를 프락시가 1.1 메시지로 변환할 때 메시지 의미 변질될 가능성 있음. 이때 불법or위조된 메시지로 번역될 수 있음
  - 긴 커넥션 유지로 인한 개인정보 누출 우려: 회전 지연 줄이기 위해 커넥션 오래 유지 → 개인 정보 유출 위험
