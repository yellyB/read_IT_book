	7장 캐시
210	클라이언트가 같은 요청해도 캐시있으면 효율적
211	클라이언트가 빠른 LAN에 있는 캐시로부터 사본 가져오면 성능 대폭 개션
212	갑자기 많은 요청->웹 서버 장애 방지
213	문서 전송 거리 줄일 수 있음
214	적중: 캐시 있음 /부적중: 캐시 없어서 원 서버로 전달되기만
215	재검사: 사본의 신선도 검사 (변경 안된거면 304 응담), 속도: 순수 캐시 적중<재검사<캐시 부적중
216	재검사 적중-304 Not Modified, 재검사 부적중-200, 개체 삭제 - 404
217	적중률: 캐시가 요청을 처리하는 비율. 0~1 사이 값. 큰값 좋은거 /   클라가 응답이 캐시에서 왔는지 아닌지 아는 방법: Date 헤더 값 -> 응답 생성일이 더 오래됐으면 응답이 캐시된 것임
218	개인 전용 캐시: 웹브라우저 내장 ,
219	공용 프락시 캐시: 여러명이 요청하면 한번만 가져와서 트래픽 줄임
220	프락시 캐시 계층들: 작은 캐시에서 부적중? 부모 캐시가 남겨진 트래픽 처리. => 계층 상단에 크고 강력한 캐시 사용
221	네트워크 아키텍처에 따라 동적으로 캐싱 할 수 있음
222	형제캐시: 선택적인 피어링 지원
223	캐시 처리 단계: 1요청받기 2파싱 3검색 4신선도검사 5응답생성 6발송 7로깅
224	 ~단계 설명~  4 신선도 검사: HTTP는 캐시가 일정 기간 사본 보유할 수 있도록 => 이 기간동안 문서는 '신선'한 것으로 간주. 기간 넘 오래? 어떤 변경 있었나 서버와 재검사
225	캐싱됨? -> 신선? -> 아닐 시 서버와 재검사 -> 통과 했으면 신선도 갱신/ 통과 못했음 서버에서 가져옴&캐시에 저장
226	캐시 만료 전에는 서버와 접촉 없이 사본 제공 가능. 만료되었으면 반드시 서버와 변경 검사해야함
227	캐시 유효기간은 컴퓨터 시계 맞아야함
228	서버 재검사: 콘텐츠 변경? 새로운 사본 가져와 클라에게 보냄 / 변경no? 새 만료일 포함한 새 헤더들만 가져와서 갱신
229	HTTP의 조건부 메서드는 '조건부 GET' 요청을 보낼 수 있어서, 서버가 갖고있는 문서와 다를 경우만 객체 본문 보내도록 ( If-Modified-Since와 If-None-Match)
230	If-Modified-Since : 날짜 재검사 : 문서 변경일이 날짜 이후면 참.
231	If-None-Match: 엔터티 태그 재검사: 문서가 자동으로 갱신된다던가 사소한 변경 등등의 이유는 위의 방법 비효율적 => 버전으로 비교
232	위 두개 모두 캐시 검사기. 조금 변경된건 같다고 간주하는 '약한 검사기'가 있고 '강한 검사기'는 콘텐츠 바뀔때마다 바뀜
233	언제 뭘 사용하냐? 클라에서는 서버가 뭘 보내주느냐에 따라 검사기 사용 결정됨
234	캐시 제어 - 얼마나 오랫동안 캐시될 수 있는가  /  no-store: 사본 금지, no-cach: 로컬에 저장 but 서버와 재검사 안하고는 캐시에서 클라로 제공 불가
235	Max-Age 응답 헤더: 서버로부터 온 후 흐른 시간, Expires 응답 헤더: 만료 날짜 명시, Must-Revalidate 응답 헤더: 캐시 성능 개선 위해 만료된 객체 제공할 수 있도록
236	휴리스틱 만료: 유명한 알고리즘 중 하나인 LM 인자 알고리즘: 문서 변경일이 예전이면 안정적일 것이므로 더 가지고 있어도 ㅇㅋ, 최근에 변경된것은 자주 변경될 가능성 있음. 짧게 캐싱
237	웹브라우저는 캐시 강제로 갱신시키는 리로드 버튼 있음. Cache-control 헤더 추가된 GET 요청으로 리프레시 가능
238	
239	캐시 제어 설정: 아파치 - 캐시 제어 헤더 설정할 수 있는 많은 매커니즘 디폴트가 가능하지 않게 설정됨. 활성화 시켜야됨 (ex, mod_headers, mod_expires, mod_cern_meta)
240	<META HTTP-EQUIV> 웹 서버는 HTML에서 해당 태그 파싱하여 응답에다가 정해진 헤더 삽입할것이다. 거의 지원 안하지만 몇몇 브라우저는 이거 다룸
241	캐시 알고리즘
242	캐시 사본 나이, 신선도 수명  <- 이거 두가지 값만 계산하면 됨
243	나이: 서버에서 생성된~지금까지의 총 시간
244	겉보기 나이는 Date 헤더 기반: 컴퓨터끼리 설정 시간 차이로 인한 문제: 클록 스큐. 이것때문에 부정확 하거나 음수가 되기도
245	네트워크 지연: 트랜잭션 느려진 경우(과부하) 추정시간 부정확할수도. => 언제 문서 요청하고 언제 도착했나 기반으로 계산(HTTP/1.1)
246	완전한 나이 계산: 캐시가 서버로부터 응답을 받은 시간, 클라가 요청해서 문서 받은 시간으로 계산
247	완전한 서버 신선도 알고리즘 코드~~
248	
249	광고 딜레마: 광고 횟수로 돈을 번다면 캐시는 접근성 좋은 장점은 있지만 접근 횟수는 줄어들어 딜레마  => 그래서 캐시 적중으로 모든 경우 재검사를 하도록 만들어서 횟수 기록
250	로그 마이그레이션: 서버로 요청이 가지 않도록해서 캐시가 모든 적중 로그 유지할 수 있또록
