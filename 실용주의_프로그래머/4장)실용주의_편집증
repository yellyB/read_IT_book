Page	김보미
181	완벽한 소프트웨어는 만들 수 없다. 불가능에 자원 낭비하지 말자
182	실용주의 프로그래머는 자기 자신도 믿지 않는다
183	
184	계약에 의한 설계 - 인간들의 '계약' 개념을 소프트웨어에 적용 가능함
185	계약에 의한 설계 DBC(Design By Contract) - 소프트웨어 시스템의 루틴은 어떠한 기대를 갖고 있다. (선행조건-후행조건-클래스불변식)
186	호출자가 루틴의 선행조건 충족?후행조건과 불변식이 참이 될것을 보증 -> 루틴과 호출자 간의 계약
187	계약에 따른 설계를 하라 : 선행조건을 이용해 사용자 입력값을 검증하지 말라
188	이 전의 '직교성'와 연관되는 내용으로 자신이 수용할 것은 엄격하게, 내어줄 것은 최소한도를 약속하라
189	DBC 의 장점은 요구사항과 보증의 문제를 설계 시기에 나열한다는 것
190	단정문 - 이런것들을 문서화하는것도 좋지만 컴파일러가 계약을 검사하도록 하는게 더 이득
191	DBC를 자체 지원하는 언어(아이펠, Sather)는 런타임 시스템에서 자동 검사함
192	DBC를 사용하면 예를들어 선행조건에서 에러가 났다면 바로 멈추기때문에 더 유리
193	루프불변식 --불변식은 바나나문제, 울타리 오류, 등등 함정에 빠지지 않게 도와줌
194	의미론적 불변식 - ex)신용카드 트랜잭션이 두 번 적용 안되도록
195	계약이 동적으로 생성되는 것이라면?컴포넌트가 지네끼리 계약할 수 있다면 우리 대신 문제 해결 가능, 소프트웨어 설계할 때 계약도 설계해라
196	
197	
198	
199	죽은 프로그램은 거짓말을 하지 않는다.
200	빨리 문제를 발견한다면 프로그램을 더 일찍 멈출 수 있음
201	실행 중인 프로그램을 그냥 종료하는 것을 비효율적일 수도 있긴하지만 걍 빨리 종료하는게 답이다.
202	자기스스로 단정지어서 프로그래밍 하지 말자. 미래는 아무도 모름
203	  -> 그러니 이런 '절대 이럴리 없어'라는 생각이 든다면 그걸 확인하는 코드를 추가하라
204	단정 기능이 코드에 과부하를 준다고+테스트 통과했다고 그 기능을 꺼버리면 안됨
205	에러 발견하려고 넣은 코드가 새로운 에러를 만드는 경우가 있다 - 하이젠버그 문제
206	불가능하다고 생각한 일이 일어날 수 있음. 예외 처리를 열심히 하자..
207	언제 예외를 사용할까 - > 모든것에 예외처리는 코드가 지저분해 질 수 있음
208	무엇이 예외적인지 판단하는 것 중요
209	ex 읽으려는 파일이 존재x? 파일이 필수라면 예외처리, but 필수아니라면 걍 에러 반환하자
210	에러 처리기는 또 다른 대안
211	
212	리소스 할당과 해제 - 시작한 것은 끝내라
213	루틴이 긴밀히 결합되어있으면 리소스 할당과 해제가 어렵다.
214	리소스를 할당하는 루틴이 해제도 책임지자
215	중첩 할당 - 리소스 할당한 순서 반대로 해제하라, / 여러 곳에서 동일한 리소스 할당할 때 할당순서 동일하게
216	할당과 해제 - 클래스 생성자, 소멸자랑 비슷
217	어떤 언어는 예외 상황일때 리소스 해제 복잡할 수 있음 - 언어마다 다름
218	
219	자바에서  : finally절 굳
220	최상위 구조에서 할당해제한 경우 세가지 방법 있음 1하위 구조 재귀적으로 해제됨 2걍 최상위만 해제됨 나머진 고아됨 3하위구조 있으면 최상위 해제불가
221	진짜 리소스 해제되었는지 점검하는 코드 있어야함
222	C와 C++에서 포인터, 자바 객체 -> 할당 해제시 null값이 되는것 : 잘못된 참조 막아줌
